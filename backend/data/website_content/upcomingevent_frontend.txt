Upcomingevent Page

;
  if (error) return <

;
  return (
    <

Upcoming Events<

All Categories<

(
                  <

))}
              <

(
                <

))}
              <

New<

Most Popular<

Relevant<

No events found.<

)}

        <

d.getDate();

            let dateTop = "";
            let dateBottom = "";

            if (startDate && endDate) {
              if (startDate.getMonth() === endDate.getMonth()) {
                dateTop = formatMonth(startDate);
                dateBottom = `${formatDay(startDate)}-${formatDay(endDate)}`;
              } else {
                dateTop = `${formatMonth(startDate)} ${formatDay(startDate)}`;
                dateBottom = `${formatMonth(endDate)} ${formatDay(endDate)}`;
              }
            } else if (startDate) {
              dateTop = formatMonth(startDate);
              dateBottom = formatDay(startDate);
            } else {
              dateTop = "--";
              dateBottom = "--";
            }

            return (
              <

) : (
                  <

No Image<

)}

                {/* Full dark gradient overlay */}
                <

)}
                  <

);
          })}
        <

perPage && (
          <

Show
                <

(
                    <

))}
                <

events
              <

Prev
              <

(
                  <

))}
              <

Page {currentPage + 1} / {Math.ceil(filteredEvents.length / perPage)}
              <

Next <

)}
      <

);
  const [searchQuery, setSearchQuery] = useState(

);
  const [categoryFilter, setCategoryFilter] = useState(

);
  const [feeFilter, setFeeFilter] = useState(

const [isShrunk, setIsShrunk] = useState(false);
  const [sortOption, setSortOption] = useState(

const [sortDir, setSortDir] = useState(

const [currentPage, setCurrentPage] = useState(0);
  const [perPage, setPerPage] = useState(12);

  const CACHE_KEY =

;
  const CACHE_TTL = 1000 * 60 * 2; // 2 minutes instead of 10 minutes for more frequent updates

  // Extract unique categories
  const categories = [
    ...new Set(events.map((e) => e.category).filter(Boolean)),
  ];

  useEffect(() => {
    const fetchEvents = async () => {
      try {
        // üîπ 1. Try loading cache first
        const cached = localStorage.getItem(CACHE_KEY);
        if (cached) {
          const { data, timestamp } = JSON.parse(cached);
          if (Date.now() - timestamp < CACHE_TTL) {
            setEvents(data);
            setFilteredEvents(data);
            setLoading(false);
            return; // ‚úÖ Load from cache, skip API
          }
        }

        // üîπ 2. No cache or stale cache, fetch from API
        const response = await axios.get(`${backend_link}/api/events`);
        if (response.data.success) {
          const eventData = response.data.events || [];
          setEvents(eventData);
          setFilteredEvents(eventData);

          // üîπ 3. Save new data to localStorage
          localStorage.setItem(
            CACHE_KEY,
            JSON.stringify({ data: eventData, timestamp: Date.now() })
          );
        } else {
          setError(

);
        }
      } catch (err) {
        console.error(err);
        setError(

);
      } finally {
        setLoading(false);
      }
    };
    fetchEvents();
  }, [backend_link]);

  // Scroll listener for sticky + blur search bar
  useEffect(() => {
    const handleScroll = () => {
      setIsShrunk(window.scrollY > 50);
    };
    window.addEventListener(

, handleScroll);
    return () => window.removeEventListener(

, handleScroll);
  }, []);

  // Reset scroll when focusing search input
  const handleFocus = () => {
    setIsShrunk(false);
    window.scrollTo({ top: 0, behavior:

});
  };

  // Force refresh events by clearing cache and refetching
  const handleRefresh = async () => {
    setLoading(true);
    localStorage.removeItem(CACHE_KEY); // Clear cache
    
    try {
      const response = await axios.get(`${backend_link}/api/events`);
      if (response.data.success) {
        const eventData = response.data.events || [];
        setEvents(eventData);
        setFilteredEvents(eventData);
        
        // Save new data to localStorage
        localStorage.setItem(
          CACHE_KEY,
          JSON.stringify({ data: eventData, timestamp: Date.now() })
        );
      } else {
        setError(

);
      }
    } catch (err) {
      console.error(err);
      setError(

);
    } finally {
      setLoading(false);
    }
  };

  // Combined search and filters (title, category, fee)
  useEffect(() => {
    const q = searchQuery.trim().toLowerCase();
    let working = events.filter(
      (event) => !q || (event.title ||

).toLowerCase().includes(q)
    );

    if (categoryFilter) {
      working = working.filter(
        (event) => event.category && event.category === categoryFilter
      );
    }

    if (feeFilter) {
      if (feeFilter ===

) {
        working = working.filter((e) => Number(e.registration_fee) === 0);
      } else if (feeFilter ===

) {
        working = working.filter((e) => Number(e.registration_fee) > 0);
      }
    }

    // Sorting
    const sorters = {
      new: (a, b) => {
        const da = new Date(a.createdAt || a.date || 0).getTime();
        const db = new Date(b.createdAt || b.date || 0).getTime();
        return da - db;
      },
      popular: (a, b) => {
        const pop = (e) =>
          e.registrations_count ??
          e.registrationCount ??
          e.popularity ??
          e.participants ??
          e.prize_money ??
          0;
        return pop(a) - pop(b);
      },
      relevant: (a, b) => {
        const now = Date.now();
        const ta = new Date(a.date || a.createdAt || 0).getTime();
        const tb = new Date(b.date || b.createdAt || 0).getTime();
        const aPast = ta < now;
        const bPast = tb < now;
        if (aPast !== bPast) return aPast ? 1 : -1;
        return ta - tb;
      },
    };

    if (sorters[sortOption]) {
      working = [...working].sort(sorters[sortOption]);
    }

    if (sortDir ===

) {
      working.reverse();
    }

    setFilteredEvents(working);
    setCurrentPage(0); // reset page when filters change
  }, [searchQuery, categoryFilter, feeFilter, events, sortOption, sortDir]);

  if (loading) return <Loader color={document.documentElement.getAttribute(

} />;
  if (error) return <p className=

>{error}</p>;
  return (
    <div className=

>
      <Header />
      <main className=

>
        <h1 className=

>Upcoming Events</h1>

        {/* üîπ Search + Filters */}
        <div
          className={`eventsPage-searchWrapper fx-bar sticky-top ${
            isShrunk ?

}`}
        >
          <div className=

>
            {/* Search Input with Icon */}
            <div className=

>
              <span className=

>üîç</span>
              <input
                id=

placeholder=

value={searchQuery}
                onChange={(e) => setSearchQuery(e.target.value)}
                onFocus={handleFocus}
                onClick={handleFocus}
                className=

/>
            </div>

            {/* Category Filter */}
            <div className=

>
              <select
                value={categoryFilter}
                onChange={(e) => setCategoryFilter(e.target.value)}
                onFocus={handleFocus}
                onClick={handleFocus}
                className=

aria-label=

>
                <option value=

>All Categories</option>
                {categories.map((cat, idx) => (
                  <option key={idx} value={cat}>
                    {cat}
                  </option>
                ))}
              </select>
              <span className=

aria-hidden=

/>
            </div>

            {/* Fee Toggle Pills */}
            <div
              className=

aria-label=

>
              {[
                { label:

},
                { label:

},
                { label:

},
              ].map((btn) => (
                <button
                  key={btn.val ||

}
                  type=

data-active={feeFilter === btn.val}
                  onClick={() => {
                    setFeeFilter(btn.val);
                    handleFocus();
                  }}
                >
                  {btn.label}
                </button>
              ))}
              <span
                className=

:
                    feeFilter ===

? 1 : feeFilter ===

? 2 : 0,
                }}
              />
            </div>

            {/* Sorting Controls */}
            <div
              className=

aria-label=

>
              <select
                className=

value={sortOption}
                onChange={(e) => {
                  setSortOption(e.target.value);
                  handleFocus();
                }}
                onFocus={handleFocus}
                aria-label=

>
                <option value=

>New</option>
                <option value=

>Most Popular</option>
                <option value=

>Relevant</option>
              </select>
              <button
                type=

onClick={() =>
                  setSortDir((d) => (d ===

))
                }
                title={`Toggle sort direction (currently ${
                  sortDir ===

Toggle sort direction

}
              </button>
            </div>

            {/* Refresh Button */}
            <div className=

>
              <button
                type=

onClick={handleRefresh}
                disabled={loading}
                title=

aria-label=

style={{
                  padding:

,
                  border:

,
                  borderRadius:

,
                  background:

,
                  cursor: loading ?

,
                  opacity: loading ? 0.6 : 1
                }}
              >
                {loading ?

}
              </button>
            </div>
          </div>
        </div>

        {filteredEvents.length === 0 && (
          <p className=

>No events found.</p>
        )}

        <div className=

>
          {filteredEvents
            .slice(currentPage * perPage, (currentPage + 1) * perPage)
            .map((event, index) => {
            const startDate = event.date ? new Date(event.date) : null;
            const endDate = event.end_date ? new Date(event.end_date) : null;

            const formatMonth = (d) =>
              d.toLocaleDateString(

});
            const formatDay = (d) => d.getDate();

            let dateTop =

;
            let dateBottom =

;

            if (startDate && endDate) {
              if (startDate.getMonth() === endDate.getMonth()) {
                dateTop = formatMonth(startDate);
                dateBottom = `${formatDay(startDate)}-${formatDay(endDate)}`;
              } else {
                dateTop = `${formatMonth(startDate)} ${formatDay(startDate)}`;
                dateBottom = `${formatMonth(endDate)} ${formatDay(endDate)}`;
              }
            } else if (startDate) {
              dateTop = formatMonth(startDate);
              dateBottom = formatDay(startDate);
            } else {
              dateTop =

;
              dateBottom =

;
            }

            return (
              <Link
                to={`/events/${event._id}`}
                key={event._id || index}
                className=

style={{ animationDelay: `${index * 70}ms` }}
              >
                {event.event_image ? (
                  <img
                    src={event.event_image}
                    alt={event.title}
                    className=

/>
                ) : (
                  <div className=

>
                    <span>No Image</span>
                  </div>
                )}

                {/* Full dark gradient overlay */}
                <div className=

aria-hidden=

/>

                {/* Blurred info bar */}
                <div className=

>
                  <div className=

>
                    <span className=

>{dateTop}</span>
                    <span className=

>{dateBottom}</span>
                  </div>

                  <div className=

aria-hidden=

/>

                  <div className=

>
                    <span className=

>
                      {(
                        event.category ||
                        event.event_type ||

).toUpperCase()}
                    </span>
                    <h3 className=

title={event.title}>
                      {event.title}
                    </h3>
                    {event.location && (
                      <p className=

>{event.location}</p>
                    )}
                  </div>
                </div>
              </Link>
            );
          })}
        </div>

        {/* Pagination Controls */}
        {filteredEvents.length > perPage && (
          <div className=

style={{ 
            display:

, 
            justifyContent:

, 
            alignItems:

, 
            margin:

,
            maxWidth:

,
            padding:

,
            flexWrap:

,
            gap:

}}>
            <div className=

style={{
              display:

,
              alignItems:

,
              gap:

,
              fontSize:

}}>
              <label style={{ display:

, alignItems:

}}>
                Show
                <select
                  value={perPage}
                  onChange={(e) => {
                    setPerPage(Number(e.target.value));
                    setCurrentPage(0);
                  }}
                  style={{
                    padding:

,
                    borderRadius:

,
                    border:

,
                    background:

,
                    color:

}}
                >
                  {[6, 12, 18, 24].map((v) => (
                    <option key={v} value={v}>
                      {v}
                    </option>
                  ))}
                </select>
                events
              </label>
            </div>
            
            <div style={{ display:

, alignItems:

}}>
              <button
                className=

onClick={() => setCurrentPage((p) => Math.max(0, p - 1))}
                disabled={currentPage === 0}
                style={{
                  padding:

,
                  border:

,
                  background: currentPage === 0 ?

var(--bg-primary)

var(--text-muted)

var(--text-primary)

,
                  cursor: currentPage === 0 ?

,
                  display:

,
                  alignItems:

,
                  gap:

}}
              >
                <FaChevronLeft size={12} /> Prev
              </button>
              
              <div className=

style={{ display:

}}>
                {Array.from({
                  length: Math.ceil(filteredEvents.length / perPage),
                }).map((_, i) => (
                  <button
                    key={i}
                    className={

+ (i === currentPage ?

)
                    }
                    onClick={() => setCurrentPage(i)}
                    style={{
                      padding:

,
                      border:

,
                      background: i === currentPage ?

var(--bg-primary)

var(--text-primary)

,
                      cursor:

,
                      minWidth:

}}
                  >
                    {i + 1}
                  </button>
                ))}
              </div>
              
              <div className=

style={{ 
                fontSize:

, 
                color:

,
                minWidth:

,
                textAlign:

}}>
                Page {currentPage + 1} / {Math.ceil(filteredEvents.length / perPage)}
              </div>
              
              <button
                className=

onClick={() =>
                  setCurrentPage((p) =>
                    Math.min(
                      Math.ceil(filteredEvents.length / perPage) - 1,
                      p + 1
                    )
                  )
                }
                disabled={
                  currentPage >=
                  Math.ceil(filteredEvents.length / perPage) - 1
                }
                style={{
                  padding:

,
                  border:

,
                  background: currentPage >= Math.ceil(filteredEvents.length / perPage) - 1 ?

var(--bg-primary)

var(--text-muted)

var(--text-primary)

,
                  cursor: currentPage >= Math.ceil(filteredEvents.length / perPage) - 1 ?

,
                  display:

,
                  alignItems:

,
                  gap: